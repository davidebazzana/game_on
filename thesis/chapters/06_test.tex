\chapter{Test e validazione del software}
Il \emph{testing} del software è un procedimento utilizzato per individuare errori e potenziali migliorie nel software in corso di sviluppo. La ricerca di questi aspetti contribuisce alla buona qualità del prodotto.\cite{test}\\

La fase di validazione invece, serve ad assicurarsi che il software rispecchi i requisiti richiesti in partenza. Può essere fatta staticamente, analizzando il codice, o dinamicamente, collaudandolo con dati di test.\\

Adesso sarà mostrato l'approccio BDD\footnote{BDD consiste in una serie di passaggi da seguire ciclicamente: \begin{itemize}
    \item Identificare le funzionalità del software.
    \item Identificare gli scenari sotto la funzionalità selezionata.
    \item Definire i passaggi per ogni scenario.
    \item Eseguire la funzionalità e fallire.
    \item Scrivere il codice per superare i test.
    \item Eeseguire la funzionalità e passare i test.
    \item Generare i resoconti dei test
\end{itemize}} (Behavior Driven Development) ad una user story presentata nel capitolo 2.\\

\emph{Come giocatore proprietario di un gioco, voglio modificare il gioco, così che lo possa mantenere aggiornato.}\\

Il codice seguente mostra il file ChangeGame.feature. La prima riga definisce la funzionalità testata. Gli step definiti (identificati da \emph{Given, When, Then}), permettono che gli scenari corrispondenti possano essere eseguiti e sono scritti in modo da rispecchiare il più possibile la definizione della user story corrispondente.\\

\newpage
\begin{lstlisting}[language=Gherkin]
Feature: The owner of a game can change a game

Background:
        Given I am a registered user

Scenario: Change the title of a game
    Given I am the owner of the game "old_title"
        When I follow "More about old_title"
    And I follow "Edit game"
    And I fill in "Title" with "new_title"
    And I click on "Commit updates"
    Then I should be on the Game-on home page
    And I should see "new_title", not "old_title" anymore

Scenario: Change the description of a game
    Given I am the owner of the game 
        "game_title" with info "old_info"
    When I follow "More about game_title"
    And I follow "Edit game"
    And I fill in "Info" with "new_info"
    And I click on "Commit updates"
    And I follow "More about game_title"
    Then I should see "new_info", not "old_info" anymore


Scenario: Change the title and the description of a game
        Given I am the owner of the game 
            "old_title" with info "old_info"
    When I follow "More about old_title"
    And I follow "Edit game"
    And I fill in "Title" with "new_title"
    And I fill in "Info" with "new_info"	  
    And I click on "Commit updates" 
    And I follow "More about new_title"
    Then I should see "new_title", not "old_title" anymore
    And I should see "new_info", not "old_info" anymore
\end{lstlisting}

Lo strumento utilizzato per analizzare il codice appena visto si chiama \emph{Cucumber}. In pratica per ogni step verrà cercata una definizione in Rby corrispondente tra i file all'interno della cartella predefinita "step\_definitions". Ecco la definizione degli step sopra riportati.\\

\begin{lstlisting}[language=Ruby]
Given("I am a registered user") do
  visit "http://www.example.com/signup"
  fill_in "Email", :with => "test_user@example.com"
  fill_in "Username", :with => "test_user"
  fill_in "Password", :with => "password_001"
  fill_in "Password confirmation", :with => "password_001"
  click_button("Sign up")
  open_email("test_user@example.com")
  visit_in_email("Confirm my account", 
    "test_user@example.com")

  @test_user_email = "test_user@example.com"
end

Given("I am the owner of the game {string}") do |game_title|
  create(:game, title: game_title, 
  user_id: User.find_by_email(@test_user_email)[:id])
end

When("I follow {string}") do |link|
  visit current_url
  click_link(link)
end

When("I fill in {string} with {string}") do |field, content|
  fill_in field, :with => content

  @test_user_email = content if field.eql?("Email")
end

When("I click on {string}") do |button|
  click_button(button)
end

Then("I should be on the Game-on home page") do
  expect(current_url).to eq("http://www.example.com/games")
end

Then("I should see {string}, 
    not {string} anymore") do |new_value, old_value|
  expect(page).to have_content(new_value)
  expect(page).to have_no_content(old_value)
end

Given("I am the owner of the game {string} 
    with info {string}") do |game_title, info|
  create(:game, title: game_title, 
    user_id: User.find_by_email(@test_user_email)[:id], info: info)
end
\end{lstlisting}

Per quanto riguarda i test si usa l'approccio TDD (Test-driven Development), che permette di creare un framework di base per l'esecuzione del codice che verrà scritto successivamente. In pratica i test vengono prima del codice vero e proprio. Per implementare tutto ciò si usa \emph{RSpec}, che permette di scrivere tesi in Ruby.\\

L'esempio seguente mostra il codice di test per la funzionalità di ricerca tra i giochi:

\begin{lstlisting}[language=Ruby]
require 'spec_helper'

RSpec.describe "Games", type: :request do
    games = [{:title => "Pet em all", :category => "Other"},
            {:title => "Cats island", :category => "Other"},
            {:title => "Dogcatcher simulator", 
                :category => "Other"},
            {:title => "Sleeping cat", 
                :category => "Other"},
            {:title => "Cat race", :category => "Racing"},
            {:title => "Purring cat", 
                :category => "Casual"},
            {:title => "Mreow", :category => "Casual"}]

    all_games = Array.new()
    cats_games = Array.new()
    casual_games = Array.new()
    casual_cats_games = Array.new()
    
    FactoryBot.create(:user, :username => "Thelonious", 
        :email => "thelonious@email.com")
    games.each do |game|
    new_game = FactoryBot.create(:game, :title => game[:title], 
        :category => game[:category])
    all_games.append(new_game)
    if(game[:title].downcase().include?("cat"))
        cats_games.append(new_game)
    end
    if(game[:category].include?("Casual"))
        casual_games.append(new_game)
    end      
    if(game[:title].downcase().include?("cat") && 
        game[:category].include?("Casual"))
        casual_cats_games.append(new_game)
    end
    end

    describe "Search by name" do
    it "Search for all the games with 'cat' in their name" do
        allow(Game).to 
            receive(:search).and_return(cats_games)
        get '/games', :params => {:game => {:title => "cat", 
            :category => "Any", :sort_criterion => "Any"}}
        expect(response).to be_successful
        expect(response).to have_http_status(:success)
        cats_games.each do |game|
        expect(response.body).to include(game[:title])
        end
    end
    end

    describe "Search by category" do
    it "Search for all the games with category 'Casual'" do
        allow(Game).to 
            receive(:search).and_return(casual_games)
        get '/games', :params => {:game => {:title => "", 
            :category => "Casual", :sort_criterion => "Any"}}
        expect(response).to be_successful
        expect(response).to have_http_status(:success)
        casual_games.each do |game|
        expect(response.body).to include(game[:title])
        end
    end
    end

    describe "Search by name and category" do
    it "Search for all the games" do
        allow(Game).to 
            receive(:search).and_return(all_games)
        get '/games', :params => {:game => {:title => "", 
            :category => "Any", :sort_criterion => "Any"}}
        expect(response).to be_successful
        expect(response).to have_http_status(:success)
        all_games.each do |game|
        expect(response.body).to include(game[:title])
        end
    end
    
    it "Search for all the games with 'cat' in their name 
        and with category 'Casual'" do
        allow(Game).to 
            receive(:search).and_return(casual_cats_games)
        get '/games', :params => {:game => {:title => "cat", 
            :category => "Casual", :sort_criterion => "Any"}}
        expect(response).to be_successful
        expect(response).to have_http_status(:success)
        casual_cats_games.each do |game|
        expect(response.body).to include(game[:title])
        end
    end
    end
end    
\end{lstlisting}

